#!/usr/bin/env python3
# ==============================================================================
# generate_version.py - Generate Ada version package from alire.toml
# ==============================================================================
# Copyright (c) 2025 Michael Gardner, A Bit of Help, Inc.
# SPDX-License-Identifier: BSD-3-Clause
# See LICENSE file in the project root.
# ==============================================================================
"""
Generate Ada version package from alire.toml

This script reads the version field from alire.toml and generates
an Ada package with version constants that can be used throughout
the application.

Usage:
    python3 tools/generate_version.py alire.toml shared/src/hybrid-version.ads
"""

import sys
import re
from pathlib import Path


def parse_toml_version(toml_path: Path) -> str:
    """Extract version string from alire.toml"""
    with open(toml_path, 'r') as f:
        for line in f:
            # Match: version = "0.1.0-dev"
            match = re.match(r'^\s*version\s*=\s*"([^"]+)"', line)
            if match:
                return match.group(1)
    raise ValueError(f"No version field found in {toml_path}")


def parse_version(version_str: str) -> dict:
    """
    Parse semantic version string into components.

    Supports:
    - "1.2.3"
    - "1.2.3-dev"
    - "1.2.3-alpha.1"
    - "1.2.3+build.123"
    - "1.2.3-beta.2+build.456"
    """
    # Pattern: MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]
    pattern = r'^(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9.]+))?(?:\+([a-zA-Z0-9.]+))?$'
    match = re.match(pattern, version_str)

    if not match:
        raise ValueError(f"Invalid semantic version: {version_str}")

    major, minor, patch, prerelease, build = match.groups()

    return {
        'full': version_str,
        'major': int(major),
        'minor': int(minor),
        'patch': int(patch),
        'prerelease': prerelease or '',
        'build': build or '',
    }


def generate_ada_package(version_info: dict) -> str:
    """Generate Ada package source code with version constants"""

    prerelease = version_info['prerelease']
    build = version_info['build']

    # Construct full version string parts
    version_parts = [
        f"{version_info['major']}.{version_info['minor']}.{version_info['patch']}"
    ]
    if prerelease:
        version_parts.append(f"-{prerelease}")
    if build:
        version_parts.append(f"+{build}")

    full_version = ''.join(version_parts)

    return f'''pragma Ada_2022;
--  ==========================================================================
--  Hybrid.Version - Application Version Information
--  ==========================================================================
--  Copyright (c) 2025 Michael Gardner, A Bit of Help, Inc.
--  SPDX-License-Identifier: BSD-3-Clause
--  See LICENSE file in the project root.
--
--  ⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️
--
--  This file is automatically generated from alire.toml by:
--    tools/generate_version.py
--
--  To update the version:
--    1. Edit the "version" field in alire.toml
--    2. Run: make generate-version (or python3 tools/generate_version.py ...)
--    3. Rebuild the project
--
--  Purpose:
--    Provides version constants extracted from alire.toml (single source
--    of truth). Bootstrap reads these constants and dependency-injects
--    them into Presentation layer for --version output.
--
--  Design Notes:
--    - Version follows Semantic Versioning 2.0.0 (semver.org)
--    - Pre-release identifiers: -dev, -alpha.N, -beta.N, -rc.N
--    - Build metadata: +build.N, +commit.HASH
--  ==========================================================================

package Hybrid.Version is

   --  Semantic Version Components
   Major : constant Natural := {version_info['major']};
   Minor : constant Natural := {version_info['minor']};
   Patch : constant Natural := {version_info['patch']};

   --  Pre-release identifier (e.g., "dev", "alpha.1", "beta.2", "rc.1")
   --  Empty string for stable releases
   Prerelease : constant String := "{prerelease}";

   --  Build metadata (e.g., "build.123", "commit.abc123")
   --  Empty string if not specified
   Build_Metadata : constant String := "{build}";

   --  Full version string (e.g., "0.1.0-dev", "1.2.3", "2.0.0-rc.1+build.456")
   Version : constant String := "{full_version}";

   --  Short version (no build metadata): "MAJOR.MINOR.PATCH[-PRERELEASE]"
   Short_Version : constant String :=
     Major'Image & "." &
     Minor'Image & "." &
     Patch'Image &
     (if Prerelease'Length > 0 then "-" & Prerelease else "");

   --  Check if this is a pre-release version
   function Is_Prerelease return Boolean is (Prerelease'Length > 0);

   --  Check if this is a development version
   function Is_Development return Boolean is (Prerelease = "dev");

   --  Check if this is a stable release
   function Is_Stable return Boolean is (not Is_Prerelease);

end Hybrid.Version;
'''


def main():
    if len(sys.argv) != 3:
        print("Usage: generate_version.py <alire.toml> <output.ads>", file=sys.stderr)
        print("Example: generate_version.py alire.toml shared/src/hybrid-version.ads", file=sys.stderr)
        sys.exit(1)

    toml_path = Path(sys.argv[1])
    output_path = Path(sys.argv[2])

    if not toml_path.exists():
        print(f"Error: {toml_path} not found", file=sys.stderr)
        sys.exit(1)

    try:
        # Extract version from alire.toml
        version_str = parse_toml_version(toml_path)
        print(f"Found version: {version_str}")

        # Parse semantic version
        version_info = parse_version(version_str)

        # Generate Ada package
        ada_code = generate_ada_package(version_info)

        # Ensure output directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write generated package
        with open(output_path, 'w') as f:
            f.write(ada_code)

        print(f"✓ Generated {output_path}")
        print(f"  Version: {version_info['full']}")
        print(f"  Major.Minor.Patch: {version_info['major']}.{version_info['minor']}.{version_info['patch']}")
        if version_info['prerelease']:
            print(f"  Pre-release: {version_info['prerelease']}")
        if version_info['build']:
            print(f"  Build: {version_info['build']}")

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
